<root>
  <config language="C#">
    <classExtension>.cs</classExtension>
    <!-- singleMode为false时，vo代码输出的子文件夹路径 -->
    <voFolder></voFolder>
    <classNameTail></classNameTail>
    <protocolEnumName>MessageType</protocolEnumName>
  </config>
  <definitionMember>
    <![CDATA[//$(comment)
        public $(className) $(member);
        ]]>
  </definitionMember>
  <definitionArray>
    <![CDATA[//$(comment)
        public $(className)[] $(member);
        ]]>
  </definitionArray>
  <accessArray>
    <![CDATA[
    $(member)[i]
    ]]>
  </accessArray>
  <decodeArray>
    <![CDATA[
            var len_$(member) = binReader.ReadUInt16();
            $(member) = new $(className)[len_$(member)];
            for (int i = 0; i < len_$(member); i++)
            {
                $(decode)
            }
            ]]>
  </decodeArray>
  <encodeArray>
    <![CDATA[
			ushort len_$(member) = (ushort)$(member).Length;
			binWriter.Write(len_$(member));
            for (int i = 0; i < len_$(member); i++)
            {
                $(encode)
            }
            ]]>
  </encodeArray>
  <params>
    <param type="byte" class="sbyte">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadSByte();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="Bin" class="byte[]">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadBytes(binReader.ReadInt32());
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member).Length);
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="bool" class="bool">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadBoolean();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="short" class="short">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadInt16();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="ushort" class="ushort">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadUInt16();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="int" class="int">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadInt32();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="uint" class="uint">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadUInt32();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="long" class="long">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadInt64();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="ulong" class="ulong">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadUInt64();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write($(member));
            ]]>
      </encode>
    </param>
    <param type="float" class="double">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadFloat();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.WriteFloat($(member));
            ]]>
      </encode>
    </param>
    <param type="string" class="string">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadUTF();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.WriteUTF($(member));
            ]]>
      </encode>
    </param>
    <param type="date" class="DateTime">
      <decode>
        <![CDATA[
            $(member) = binReader.ReadDate();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.WriteDate($(member));
            ]]>
      </encode>
    </param>
    <param type="struct" class="struct">
      <decode>
        <![CDATA[
            $(member) = new $(className)();
            $(member).decode(binReader);
            ]]>
      </decode>
      <encode>
        <![CDATA[
            $(member).encode(binWriter);
            ]]>
      </encode>
    </param>
    <param type="enum" class="enum">
      <decode>
        <![CDATA[
            $(member) = ($(className))binReader.ReadInt32();
            ]]>
      </decode>
      <encode>
        <![CDATA[
            binWriter.Write((int)$(member));
            ]]>
      </encode>
    </param>
  </params>

  <ProtocolVOClass>
    <![CDATA[
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using KLib.utils;

namespace protocol.vo
{
    //$(comment)
    public class $(className) : BaseProtocolVO
    {
        
        static public $(className) CreateInstance()
        {
            return new $(className)();
        }
        
        $(definition)
        
        public $(className)() : base(MessageType.$(messageName))
        {

        }
        
        override public void decode(EndianBinaryReader binReader)
        {
        $(decode)
        }
        
        override public void encode(EndianBinaryWriter binWriter)
        {
        $(encode)
        }
        
        public delegate void MessageHandler($(className) msg);
        static private List<MessageHandler> list_handler = new List<MessageHandler>();
        
        static public void RegisterHandler(MessageHandler handler)
        {
            list_handler.Add(handler);
        }

        static public void CallHandler($(className) msg)
        {
            int i = 0;
            while (i < list_handler.Count)
            {
                var handler = list_handler[i];
                //对象被回收了的  自动移除
                if (handler.Target == null || handler.Target.ToString() == "null")
                {
                    list_handler.RemoveAt(i);
                    continue;
                }
                try
                {
                    handler(msg);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message);
                }
                i++;
            }
        }
    }

}
]]>
  </ProtocolVOClass>

  <ProtocolEnumClass>
    <![CDATA[
using System;

namespace protocol
{
    //$(comment)
    public enum $(className)
    {
        $(content)
    }
}
]]>
  </ProtocolEnumClass>
  <definitionEnum>
    <![CDATA[
        //$(comment)
        $(member) = $(value),
        ]]>
  </definitionEnum>
  <MessageCreaterClass fileName="ProtocolCenter.cs" >
    <![CDATA[
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using protocol.vo;

namespace protocol
{
    public delegate void CommonMessageHandler(BaseProtocolVO vo);
    public class ProtocolCenter : IProtocolVOCreater
    {
        
        private Dictionary<int, Func<BaseProtocolVO>> dic_creater = new Dictionary<int, Func<BaseProtocolVO>>();
        
        static private Dictionary<MessageType, List<CommonMessageHandler>> dic_handler = new Dictionary<MessageType, List<CommonMessageHandler>>();
        
        public BaseProtocolVO CreateProtocolVO(int messageId)
        {
            return dic_creater[messageId]();
        }
        
        public BaseProtocolVO CreateProtocolVO(MessageType messageType)
        {
            return CreateProtocolVO((int)messageType);
        }
        
        public void RegisterCreater(MessageType messageType, Func<BaseProtocolVO> packageCreateFun)
        {
            dic_creater[(int)messageType] = packageCreateFun;
        }
        
        static public void RegisterMessageHandler(MessageType messageType, CommonMessageHandler handler)
        {
            
            List<CommonMessageHandler> list_handler;
            if (dic_handler.TryGetValue(messageType, out list_handler) == false)
            {
                list_handler = dic_handler[messageType] = new List<CommonMessageHandler>();
            }
            list_handler.Add(handler);

        }
        
        public ProtocolCenter()
        {
            $(content)
        }
        
        static public void DispatchMessage(BaseProtocolVO msg)
        {
            
            List<CommonMessageHandler> list_handler;
            if (dic_handler.TryGetValue(msg.MessageType, out list_handler))
            {
                int i = 0;
                while (i < list_handler.Count)
                {
                    var handler = list_handler[i];
                    //对象被回收了的  自动移除
                    if (handler.Target == null || handler.Target.ToString() == "null")
                    {
                        list_handler.RemoveAt(i);
                        continue;
                    }
                    try
                    {
                        handler(msg);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e.Message);
                    }
                    i++;
                }
            }
            
            switch (msg.MessageType)
            {
$(dispatch)
            }
        }
        
        $(creater)
        
    }
}
]]>
  </MessageCreaterClass>
  <MessageRegisterCreater>
    <![CDATA[
            RegisterCreater(MessageType.$(className), $(className).CreateInstance);
            ]]>
  </MessageRegisterCreater>
  <MessageDispatcherItem>
    <![CDATA[
                case $(protocolEnumName).$(messageName):
                    $(messageName).CallHandler(($(messageName))msg);
                    break;
]]>
  </MessageDispatcherItem>
</root>